# Damage & Conditions Overview
- `src/domain/damage.zig` defines the shared damage taxonomy. `Kind`/`Category` enumerate physical/magical/elemental/biological families, while `Instance` and `Packet` describe concrete attacks (amount, type mix, penetration). Scaling metadata and helper functions (`afterLayer`, `penaltiesFor`) keep math reusable.
- Armour/body resistance is encoded via `Resistance`, `Vulnerability`, `Susceptibility`, and `Immunity` structs so mitigation tweaks remain data-driven. Condition susceptibility hooks allow armour/weapons to tag agents with specific condition risks.
- Conditions live in the `Condition` enum, with runtime `ActiveCondition { condition, expiration }`. A centralized `condition_penalties` table maps every condition to a `CombatPenalties` record (hit chance modifier, damage multiplier, defense multiplier, dodge/footwork adjustments). Combining penalties is handled through data (`CombatPenalties.combine`) so context/resolution code just folds the table outputs.
- Resource-based or computed conditions (blood loss, sensory impairment, pain/trauma, adrenaline phases, etc.) and explicit conditions added by effects all converge on the same enum/table. Cards reference conditions declaratively through `Predicate.has_condition` / `.lacks_condition`, and effects can add/remove via `Effect.add_condition`/`remove_condition`, aligning with the “logic as data” goal.