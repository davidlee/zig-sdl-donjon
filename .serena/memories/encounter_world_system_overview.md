# Encounter & World System Overview
- `src/domain/world.zig` owns the high-level game state: allocator, event queue, encounter manager, random sources, entity registries, card registry, player agent, FSM, tick resolver, command handler, and event processor. `World.init` wires these subsystems; `World.step`/`processTick` advance encounters, execute timelines, and feed events into the processor.
- Encounters (`world.encounter`) maintain per-agent state: engagements, timelines, hand/deck views, and AI directors. Encounter states expose helpers like `stateFor` / `current.timeline.slots()` so resolution, apply, and presentation layers can inspect plays without duplicating data.
- Non-combat systems (menus, overworld) interact with `World` via commands and FSM transitions (`World.transitionTo`, `World.transitionTurnTo`), keeping the combat machinery dormant when not in an encounter. Random draws go through `World.drawRandom`, which multiplexes deterministic streams (combat, loot, etc.).
- Event routing stays centralized: world systems emit `events.Event` instances, and `World.eventProcessor` handles domain reactions (e.g., updating UI state, logging). This separation allows adding new game modes or out-of-combat content without entangling them with combat-specific code.