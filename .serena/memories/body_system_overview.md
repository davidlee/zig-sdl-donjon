# Body System Overview
- `src/domain/body.zig` defines biomechanical data for agents. A `Body` is created from a `PartDef` plan (e.g. `HumanoidPlan`) and stores runtime `Part` instances plus hash indexes for lookups. Each `Part` tracks tissues, trauma multipliers, flags (`can_grasp`, `can_see`, etc.), major artery info, wound history, severity, and parent/enclosure links so damage can propagate up/down the tree.
- Helper structs describe tissue composition (`TissueTemplate`, `TissueLayer`), wound slices (`Wound`, `LayerDamage`), tagged coverage/exposure probabilities, and enumerations for part tags, sides, and heights. These data tables let new species be defined declaratively and keep attack resolution generic.
- Runtime APIs expose composable queries: iterators for children/enclosed parts, `computeEffectiveIntegrities` to fold wound severity up the tree, `graspStrength`, `functionalGraspingParts`, `mobilityScore`, `visionScore`, `hearingScore`, `graspingPartBySide`, etc. These feed higher-level systems (conditions, combat modifiers) without hardcoding limb names.
- Damage application is also data-driven: `applyDamageWithEvents` walks armour results, updates wounds, checks for severing/artery hits, emits events, and updates severity. Severity helpers convert between `Severity` enums and integrity, and wound structures accumulate arbitrary damage sequences.
- Because all anatomical detail lives in data (plans, flags, tissue layers) and the API exposes capability-based queries, new mechanics (conditions, penalties, targeting constraints) can hook into capability scores rather than bespoke logic per limb.