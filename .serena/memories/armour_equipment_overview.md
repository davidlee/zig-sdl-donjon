# Armour & Equipment Overview
- `src/domain/armour.zig` models armor declaratively through templates and coverage patterns. A `Template` references a `Material` (resistance curves, durability, hardness/flexibility, quality) and a `Pattern` (list of `PatternCoverage` entries describing which `PartTag`+`Side` each layer protects, the `Totality` of coverage, and layer ordering).
- At runtime, equipping creates `Instance` structs with `InstanceCoverage` records keyed by body part/side/layer, tracking totality, material, and integrity per layer. `Stack.buildFromEquipped` aggregates all equipped pieces into a per-part armor stack without bespoke code per armour type.
- Resolution APIs (`resolveThroughArmour` / `resolveThroughArmourWithEvents`) process incoming damage packets layer by layer, applying material resistances/vulnerabilities, hardness deflections, penetration reduction, and gap chances. Results report remaining penetration, deflection flags, destroyed layers, and event hooks so downstream systems can respond generically.
- Because both material behavior and coverage are data-driven, adding new armor types only requires new templates/patterns. Combat/damage logic always queries the stack for protection, keeping the pipeline flexible and composable with other systems (body plans, events, condition triggers).