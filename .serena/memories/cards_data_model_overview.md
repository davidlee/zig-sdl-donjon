# Cards Data Model Overview
- Cards are described declaratively in `src/domain/cards.zig` through `Template` values: `Template` holds basic identity (`id`, `kind`, `rarity`, `tags`, `cost`, etc.), playability metadata (`PlayableFrom`, `combat_playable`, `cooldown`, optional rune icon), and a list of `Rule`s.
- A `Rule` couples a `Trigger` with a `Predicate` and one or more `Expression`s. Triggers cover lifecycle hooks (`on_play`, `on_draw`, `on_tick`, `on_commit`, `on_resolve`) and event subscriptions via `on_event: EventTag`. Predicates (`Predicate` union) encode card validity / gating conditions such as tag requirements, weapon reach, range, advantage thresholds, condition presence/absence, composable via `not`, `all`, `any`.
- Each `Expression` describes work to perform: the `Effect` union carries payloads for combat techniques, resource modifications, card movement, condition changes, emitting events, play modification/cancellation, range/position adjustments, etc. Expressions also carry optional `filter: ?Predicate` guards and `target: TargetQuery` descriptors so targeting stays data-driven.
- Tagging is represented by `TagSet`, a packed bitset that supports queries (`hasTag`, `hasAnyTag`, `canPlayInPhase`). Other helper structs (`ChannelSet`, `Technique`, `ModifyPlay`, `TargetQuery`, etc.) keep card behavior modular and allow new cards/mechanics to be composed by assembling data rather than branching logic.
- Because every card behavior flows through this rules→predicates→expressions pipeline, new mechanics (e.g., condition-triggered cards, hand auras) should extend the existing unions/enums so they can be represented as data; bespoke imperative handling is discouraged.
