# T015: Dud Card Definitions & Injection
Created: 2026-01-08

## Problem statement / value driver

Conditions should inject dud cards into hand. Injection must be declarative via event system, not imperative if-chains.

### Scope - goals

- Define dud cards (Wince, Retch, Stagger, Tremor, Blackout)
- Condition gain emits event
- Dud cards subscribe via Trigger.on_event
- Cards exhaust on play

### Scope - non-goals

- Card system extensions (T014)

## Background

### Relevant documents

- `doc/trauma_wounds_conditions_ph2.md` (Phase 4.6)
- Architectural Alignment Review section
- `cards_data_model_overview` memory

### Key files

- `src/domain/events.zig` (EventTag)
- `src/domain/cards.zig` (Template, Rule)
- Card definitions file (TBD - possibly new file for status cards)
- Condition application path (where conditions are added)

### Existing systems

- Cards subscribe to events via `Trigger.on_event: EventTag`
- `Effect.move_card` moves cards between zones
- `Effect.exhaust_card` removes card from game
- Pattern: declarative rules, not imperative injection

## Changes Required

### 1. Add condition_gained event (`events.zig`)

```zig
pub const EventTag = enum {
    // ... existing events ...
    condition_gained,
};

// Event payload structure
pub const Event = union(EventTag) {
    // ... existing ...
    condition_gained: struct {
        agent_id: entity.ID,
        condition: damage.Condition,
    },
};
```

### 2. Emit event when condition gained

In Agent.addCondition (or wherever conditions are applied):

```zig
pub fn addCondition(self: *Agent, event_sys: *EventSystem, condition: Condition, expiration: Expiration) !void {
    try self.conditions.append(self.alloc, .{ .condition = condition, .expiration = expiration });
    try event_sys.push(.{ .condition_gained = .{
        .agent_id = self.id,
        .condition = condition,
    } });
}
```

### 3. Add Predicate for condition matching

```zig
// Predicate to match condition_gained events
event_condition: Condition,  // matches if event is condition_gained with this condition
```

### 4. Define dud cards

```zig
// NOTE: Injection is handled externally - when condition_gained event fires,
// the event processor creates an instance of the appropriate dud card template
// and adds it to the affected agent's hand.
//
// Exhaust is via cost.exhausts = true (automatic), not Effect.exhaust_card.
// Rules only needed for blocking behavior (on_play_attempt).

pub const wince = Template{
    .id = .wince,
    .kind = .status,
    .name = "Wince",
    .description = "Involuntary flinch. Exhausts when played.",
    .tags = .{ .involuntary = true, .phase_selection = true },
    .cost = .{ .stamina = 0, .time = 0.6, .exhausts = true }, // time cost makes it actually punishing
    .rules = &.{}, // No special rules - just wastes a play
};

pub const tremor = Template{
    .id = .tremor,
    .kind = .status,
    .name = "Trembling Hands",
    .description = "Blocks precision techniques while in hand.",
    .tags = .{ .involuntary = true, .phase_selection = true },
    .cost = .{ .stamina = 0, .time = 0, .exhausts = true },
    .rules = &.{
        Rule{
            .trigger = .on_play_attempt,
            .valid = .{ .has_tag = .{ .precision = true } },
            .expressions = &.{.{ .effect = .cancel_play, .target = .self }},
        },
    },
};

// Similar for: retch (.nauseous), stagger (.unsteady), blackout (.reeling)
```

### 5. Card instantiation & injection mechanism

Dud cards should be **cloned on demand**, not pre-allocated. But since the card instance doesn't exist yet, it can't subscribe to events for its own injection.

**Proposed approach**: Condition→DudCard mapping in a registry/table
```zig
// In damage.zig or a new dud_cards.zig
pub const condition_dud_cards = std.EnumMap(Condition, ?TemplateID).init(.{
    .distracted = .wince,
    .trembling = .tremor,
    .nauseous = .retch,
    .unsteady = .stagger,
    .reeling = .blackout,
    // ... others null
});
```

When `condition_gained` event fires, the event processor:
1. Looks up mapping for the condition
2. If dud card exists, clones Template → Instance
3. Adds Instance to affected agent's hand

This keeps injection logic localized (event processor + mapping table) while cards remain purely behavioral.

## Test / Verification Strategy

### success criteria / ACs

- [ ] condition_gained event emitted when condition added
- [ ] Wince injected when .distracted gained
- [ ] Tremor blocks .precision cards while in hand
- [ ] Playing dud exhausts it
- [ ] Build passes, tests pass, lint clean

### unit tests

- Test event emission on condition gain
- Test dud card injection via event subscription
- Test blocking behavior
- Test exhaust on play

## Challenges / Tradeoffs / Open Questions

- **Where do dud cards live before injection?**
  - Answer: Clone-on-demand from Template (like always_available), not pre-allocated limbo

- **Which agent's hand?**
  - The agent who gained the condition (event payload includes agent_id)

- **Multiple condition gains = multiple duds?**
  - Yes, each gain triggers injection (per earlier design decision)

- **Should dud cards be locked once committed (no Focus un-commit)?**
  - Thematically yes - involuntary actions shouldn't be cancellable
  - Possible approach: extend `canWithdrawPlay` to check `involuntary` tag
  - Current impl (`validation.zig:114-116`): only checks modifier_stack_len, takes Play not card
  - Would need to pass card/template or look up from play.action
  - Could add: `if (card.template.tags.involuntary) return false;`
  - This reuses existing tag without special-casing - clean extension
  - **Decision needed**: implement in T015 or defer?

## Progress Log / Notes

**Design revision**: Original plan had cards subscribe to events for self-injection via limbo zone. Revised to clone-on-demand with condition→card mapping table. Injection is handled by event processor consulting the mapping, not by card rules. Cards define only their in-hand/on-play behavior. This is more scalable and matches `always_available` instantiation pattern.

### Reference: Card instantiation patterns

**Pool cards** (always_available, spells_known):
```
Master instance lives in Agent's pool → clone on play → destroy clone after resolution
- CardRegistry.clone(master_id) creates ephemeral copy
- CardRegistry.destroy(clone_id) frees after resolution
- Cooldown tracked against master_id
```

**Dud cards** (simpler - no master):
```
Template only (no master instance) → create on condition → destroy on exhaust
- CardRegistry.create(dud_template) creates instance directly in hand
- CardRegistry.destroy(id) frees when exhausted
- No clone needed - the instance IS the ephemeral copy
```

**Key files:**
- `src/domain/world.zig:34-155` - CardRegistry with create/clone/destroy
- `src/domain/apply/command_handler.zig:49-100` - playValidCardReservingCosts (pool clone flow)
- `src/domain/apply/costs.zig:50-51` - destroy pool clone after resolution
- `src/domain/apply/event_processor.zig:57-70` - cleanupCardBySource

**Injection implementation approach:**
1. In event_processor, when processing `condition_gained` event:
2. Look up `condition_dud_cards.get(event.condition)`
3. If template exists: `card_registry.create(template)` → add to agent's hand
4. Emit `card_moved` event for UI

**Exhaust on play:**
- Use `.cost = .{ .exhausts = true }` in template (not Effect.exhaust_card)
- `apply/costs.zig:55-66` handles moving to exhaust zone automatically
- Dud cards need `.cost = .{ .stamina = 0, .time = 0, .exhausts = true }`
