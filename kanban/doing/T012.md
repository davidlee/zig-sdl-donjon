# T012: Pain & Trauma Conditions
Created: 2026-01-08
IMPORTANT: DEPENDS ON T018 - do that first!

## Problem statement / value driver

Pain and trauma resources need to trigger conditions at thresholds. These conditions affect combat penalties.

### Scope - goals

- Table-driven resource→condition thresholds (not if-chains)
- New conditions: distracted, suffering, agonized, dazed, unsteady, trembling, reeling, incapacitated
- Penalties in condition_penalties table
- ConditionIterator yields conditions based on resource ratios

### Scope - non-goals

- Adrenaline (T013)
- Dud card injection (T015)

## Background

### Relevant documents

- `doc/trauma_wounds_conditions_ph2.md` (Phase 4.3)
- Architectural Alignment Review section

### Key files

- `src/domain/damage.zig`:
  - `Condition` enum (line ~58-102) - add new conditions
  - `condition_penalties` table (line ~138-212) - add penalty entries
  - Add `ResourceAccessor`, `ResourceConditionThreshold`, `resource_condition_thresholds` after penalties table
- `src/domain/combat/agent.zig`:
  - `ConditionIterator` (line ~298-373) - add table-driven phase
  - Add `Agent.getResourceRatio()` helper method

### Existing systems

- `damage.condition_penalties` table already maps conditions to penalties
- `ConditionIterator` already has computed phases for blood loss, sensory impairment
- Pattern: loop over data table, not switch on hardcoded values

## Changes Required

### 1. Add conditions to enum (`damage.zig`)

```zig
pub const Condition = enum {
    // ... existing ...
    distracted,
    suffering,
    agonized,
    dazed,
    unsteady,
    trembling,
    reeling,
    incapacitated,
};
```

### 2. Add resource→condition threshold table (`damage.zig`)

```zig
pub const ResourceAccessor = enum { pain, trauma, blood, morale };

pub const ResourceConditionThreshold = struct {
    resource: ResourceAccessor,
    min_ratio: f32,
    condition: Condition,
};

pub const resource_condition_thresholds = [_]ResourceConditionThreshold{
    // Incapacitation (highest priority)
    .{ .resource = .pain, .min_ratio = 0.95, .condition = .incapacitated },
    .{ .resource = .trauma, .min_ratio = 0.95, .condition = .incapacitated },
    // Pain conditions (worst first)
    .{ .resource = .pain, .min_ratio = 0.85, .condition = .agonized },
    .{ .resource = .pain, .min_ratio = 0.60, .condition = .suffering },
    .{ .resource = .pain, .min_ratio = 0.30, .condition = .distracted },
    // Trauma conditions (worst first)
    .{ .resource = .trauma, .min_ratio = 0.90, .condition = .reeling },
    .{ .resource = .trauma, .min_ratio = 0.70, .condition = .trembling },
    .{ .resource = .trauma, .min_ratio = 0.50, .condition = .unsteady },
    .{ .resource = .trauma, .min_ratio = 0.30, .condition = .dazed },
};
```

### 3. Add penalties to `condition_penalties` table

```zig
.distracted => .{ .defense_mult = 0.95, .hit_chance = -0.05 },
.suffering => .{ .defense_mult = 0.85, .hit_chance = -0.15, .damage_mult = 0.9 },
.agonized => .{ .defense_mult = 0.70, .hit_chance = -0.30, .damage_mult = 0.7, .dodge_mod = -0.2 },
.dazed => .{ .hit_chance = -0.10, .defense_mult = 0.95 },
.unsteady => .{ .footwork_mult = 0.7, .dodge_mod = -0.15 },
.trembling => .{ .hit_chance = -0.10, .damage_mult = 0.8 },
.reeling => .{ .footwork_mult = 0.4, .hit_chance = -0.25, .defense_mult = 0.7, .dodge_mod = -0.25 },
.incapacitated => .{ /* terminal - handled specially */ },
```

### 4. Add `Agent.getResourceRatio()` helper

```zig
pub fn getResourceRatio(self: *const Agent, accessor: damage.ResourceAccessor) f32 {
    return switch (accessor) {
        .pain => self.pain.ratio(),
        .trauma => self.trauma.ratio(),
        .blood => self.blood.ratio(),
        .morale => self.morale.ratio(),
    };
}
```

### 5. ConditionIterator loops over table

Replace hardcoded phases with table loop. Track which resources have already yielded a condition to avoid duplicates (yield only worst applicable per resource).

## Test / Verification Strategy

### success criteria / ACs

- [x] Pain at 35% yields `.distracted` only
- [x] Pain at 65% yields `.suffering` only (not both)
- [x] Trauma at 55% yields `.unsteady` only
- [x] Pain or trauma at 96% yields `.incapacitated`
- [x] Build passes, tests pass, lint clean

### unit tests

- Test each threshold boundary
- Test that only worst condition per resource is yielded
- Test incapacitation from either resource

## Quality Concerns / Risks

- **Ordering matters**: Table must be ordered worst-first per resource
- **Future extensibility**: Morale conditions can be added by extending table

## Implementation Context

### Existing ConditionIterator Structure

Current phases in `ConditionIterator.next()`:
- Phase 0: balance check (`.unbalanced`)
- Phases 1-3: blood loss, hardcoded if-chains (`.hypovolemic_shock`, `.bleeding_out`, `.lightheaded`)
- Phases 4-5: sensory impairment (`.blinded`, `.deafened`)
- Phases 6-7: engagement pressure (`.pressured`, `.weapon_bound`)

The blood loss checks (phases 1-3) are currently hardcoded - same pattern we want to avoid. Consider migrating them to the table too for consistency (optional, could be follow-up).

### Existing Condition Enum Notes

- `.shaken` and `.fearful` already exist in enum (from old design) - these are NOT the same as our new pain/trauma conditions. Keep them for now (morale system may use them later).
- Blood loss conditions already exist: `.lightheaded`, `.bleeding_out`, `.hypovolemic_shock`

### Integration Strategy

1. Add new conditions to enum after existing ones
2. Add `ResourceAccessor` enum and `resource_condition_thresholds` table
3. Add new phase(s) to ConditionIterator that loops over table
4. Keep existing blood loss phases for now OR migrate to table (decide on scope)

### Suggested Phase Numbering

Option A (minimal change):
- Phases 0-7: keep existing
- Phase 8: new table-driven resource conditions (pain, trauma)

Option B (refactor blood loss too):
- Phase 0: balance
- Phase 1: table-driven resource conditions (blood, pain, trauma)
- Phases 2-3: sensory
- Phases 4-5: engagement

Recommend Option A for smaller diff, Option B for architectural purity.

## Progress Log / Notes

Architectural approach: data table instead of if-chains, so future resources hook in by adding rows.