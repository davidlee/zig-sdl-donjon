# T004: Manoeuvres

**Status**: doing
**Phase**: 4 of 6 (Timing/Simultaneity/Positioning)
**Design Doc**: `doc/timing_simultaneity_positioning.md`
**Depends on**: T003 (Targeting & Range) - COMPLETE

## Goal

Footwork cards that change positioning; overlay synergies with weapon techniques.

## Design Decisions

### Focal Targeting

Manoeuvres use `.single` targeting. The target identifies the "focal" engagement
for range modification. When unspecified, defaults to first weapon technique's
target on timeline, or first engagement.

### Overlay Bonuses

Rather than expressing overlay synergy through the card rules system, manoeuvres
declare bonuses as technique metadata. Resolution code aggregates bonuses from
overlapping manoeuvres via a dedicated `getOverlayBonuses()` helper (keeps
`CombatModifiers` focused on conditions).

```zig
pub const OverlayBonus = struct {
    offensive: struct {
        to_hit_bonus: f32 = 0,
        damage_mult: f32 = 1.0,
    } = .{},
    defensive: struct {
        defense_bonus: f32 = 0,
    } = .{},
};
```

### Range Propagation

`modify_range.propagate` implements spatial coherence for multi-engagement:
- Advancing n steps toward focal also advances n-1 toward other far enemies
- Retreating n steps from focal also retreats n-1 from other close enemies
- No-op in single engagement (current state); activates in Phase 5

### Manoeuvre Resolution Timing

Manoeuvre effects (range modification) execute **before** `tickResolver.resolve()`
so that attacks use updated range for validation. This is achieved by calling
`executeManoeuvreEffects()` before combat resolution in `world.resolveTick()`.

### Standing Still as Computed Condition

Rather than bespoke resolution logic, `.stationary` is a computed condition
(like `.pressured`, `.unbalanced`). This requires wiring computed conditions
into resolution properly — currently only stored conditions are checked.

- Add `.stationary` to `damage.Condition`
- Compute when agent has no footwork in their timeline this tick
- Update resolution to use `activeConditions()` iterator
- Effect: +10% hit chance for attacker against stationary defender

### Effect Target Context (Preflight finding)

Current `applyResolveEffect` takes `agent: *Agent`, but `modify_range` needs an
**engagement** target. Solution: Add `applyEngagementEffect` alongside existing
agent-targeted effect application.

## Tasks

### Domain: New Types

- [x] 4.1 Add `Effect.modify_range: struct { steps: i8, propagate: bool = true }`
- [x] 4.2 Add `OverlayBonus` struct to `Technique`

### Domain: Range Modification

- [x] 4.3 Add `applyEngagementEffect()` in apply.zig for engagement-targeted effects
- [x] 4.4 Implement `modify_range` handling: adjust `engagement.range` by steps (clamped)
- [x] 4.5 Add `executeManoeuvreEffects()` — processes manoeuvre cards before combat resolution
- [x] 4.6 Call `executeManoeuvreEffects()` in `world.processTick()` before `tickResolver.resolve()`
- [x] 4.7 Propagate logic stub (no-op for single engagement, ready for Phase 5)

### Domain: Overlay Bonuses

- [x] 4.8 Add `getOverlayBonuses()` helper in resolution.zig — scans timeline for overlapping manoeuvres
- [x] 4.9 Integrate overlay bonuses into attack resolution (to_hit, damage_mult)
- [x] 4.10 Integrate overlay bonuses into defense resolution (defense_bonus)

### Domain: Stationary Condition

- [x] 4.11 Add `.stationary` to `damage.Condition` enum
- [x] 4.12 Add `hasFootworkInTimeline()` helper (deviation: compute at resolver level, not iterator)
- [x] 4.13 Add `is_stationary` flag to `DefenseContext` (deviation from timeline-in-iterator approach)
- [x] 4.14 Add `engagement` field to `DefenseContext` for computed conditions
- [x] 4.15 Update `CombatModifiers.forAttacker` to use `activeConditions()` iterator
- [x] 4.16 Update `CombatModifiers.forDefender` to use `activeConditions()` iterator
- [x] 4.17 Handle `.stationary` via `dodge_mod -= 0.10` (matches existing pattern for hit chance)

### Content: Manoeuvre Cards

- [x] 4.18 Create manoeuvre templates in `card_list.zig`:
  - `advance`: close 1 step, overlay +10% damage to offensive
  - `retreat`: open 1 step, overlay +0.1 defense to defensive
  - `sidestep`: no range change, overlay +5% to_hit to offensive
  - `hold`: no movement (stationary penalty applies via `.footwork` channel)
- [x] 4.19 Add `.footwork` channel to manoeuvre techniques
- [x] 4.20 Add manoeuvres to `always_available` pool

### Contracts (for UI)

- [ ] 4.21 Verify `Command.play_card` handles footwork cards correctly
- [ ] 4.22 Document UI contract for footwork placement (timeline positioning deferred)

### Tests

- [ ] 4.23 `modify_range` adjusts engagement.range correctly
- [ ] 4.24 Range clamped at boundaries (can't go below .clinch or above .far)
- [ ] 4.25 Footwork overlaps weapon channel (no conflict)
- [ ] 4.26 `getOverlayBonuses` aggregates from multiple overlapping manoeuvres
- [ ] 4.27 Overlay damage bonus applied in attack resolution
- [ ] 4.28 `.stationary` computed when no footwork in timeline
- [ ] 4.29 `.stationary` NOT computed when footwork present
- [ ] 4.30 Stationary defender: +10% hit chance for attacker
- [ ] 4.31 Computed conditions (pressured, unbalanced) now affect resolution

## Pool Manoeuvres

| Card | Range Effect | Overlay Bonus | Cost |
|------|--------------|---------------|------|
| Advance | Close 1 step | +10% damage to offensive | 1.5 stam, 0.3s |
| Retreat | Open 1 step | +0.1 defense to defensive | 1.0 stam, 0.2s |
| Sidestep | None | +5% to_hit to offensive | 1.5 stam, 0.2s |
| Hold | None | None (stationary penalty applies) | 0 stam, 0.3s |

## Sequence

```
1. Types (4.1-4.2)
   |
   +---> 2. Range modification (4.3-4.7)
   |
   +---> 3. Overlay bonuses (4.8-4.10)
   |
   +---> 4. Stationary condition (4.11-4.17)
   |
   v
5. Manoeuvre cards (4.18-4.20) — needs types + effects wired
   |
   v
6. Contracts & tests (4.21-4.31)
```

Steps 2, 3, 4 can proceed in parallel after step 1.

## Acceptance Criteria

- [ ] Advance closes range by 1 step
- [ ] Footwork overlaps weapon channel in timeline
- [ ] Advance + thrust gives +10% damage
- [ ] Sidestep + thrust gives +5% to_hit
- [ ] Retreat + block gives +0.1 defense
- [ ] Stationary defender = +10% hit chance for attacker
- [ ] Computed conditions (pressured, unbalanced, weapon_bound) now affect resolution
- [ ] Manoeuvres available in always_available pool

## Key Files

> **Note**: The codebase underwent decomposition refactoring (see `doc/decomposition.md`).
> Files like `resolution.zig`, `tick.zig`, `apply.zig`, `combat.zig` are now thin re-export
> modules. The actual code lives in submodules (e.g., `resolution/outcome.zig`).

```
src/domain/damage.zig                 # Condition.stationary (4.11)
src/domain/cards.zig                  # Effect.modify_range, OverlayBonus on Technique
src/domain/card_list.zig              # manoeuvre templates (4.18-4.20)
src/domain/combat.zig                 # Re-exports from combat/ submodules
src/domain/combat/state.zig           # CombatState, CombatZone
src/domain/apply.zig                  # Re-exports from apply/ submodules
src/domain/apply/validation.zig       # Card validation, predicate evaluation
src/domain/apply/targeting.zig        # Target evaluation
src/domain/resolution.zig             # Re-exports from resolution/ submodules
src/domain/resolution/context.zig     # AttackContext, DefenseContext, getOverlayBonuses, AggregatedOverlay
src/domain/resolution/outcome.zig     # resolveOutcome, resolveTechniqueVsDefense, calculateHitChance
src/domain/resolution/damage.zig      # createDamagePacket
src/domain/tick.zig                   # Re-exports from tick/ submodules
src/domain/tick/resolver.zig          # TickResolver.resolve - calls resolution functions
src/domain/world.zig                  # resolveTick ordering, executeManoeuvreEffects call
```

## Preflight Notes (2026-01-06)

### Code Context Reviewed

> **Note**: Line numbers below may be stale after decomposition. Use symbol search instead.

- `Effect` union → `cards.zig` (search: `pub const Effect`)
- `Technique` struct → `cards.zig` (search: `pub const Technique`)
- `ConditionIterator` → `combat.zig` (search: `pub const ConditionIterator`)
- `CombatModifiers.forAttacker/forDefender` → `resolution/context.zig`
- `applyResolveEffect` → `apply.zig` (effects not yet extracted)
- `executeResolvePhaseRules` → `apply.zig`
- `TickResolver.resolve` → `tick/resolver.zig`
- `Reach` enum → `combat.zig` (search: `pub const Reach`)
- `damage.Condition` enum → `damage.zig`

### Key Findings
1. Resolution uses `.conditions.items` directly — computed conditions not wired in
2. `applyResolveEffect` only handles agent targets — need engagement target path
3. `executeResolvePhaseRules` runs after `tickResolver.resolve()` — manoeuvres need earlier execution
4. Timeline accessible via `enc.stateFor(agent.id).current` during resolution

---

## Implementation Progress (2026-01-06)

### Completed
1. **Types** (4.1-4.2): `Effect.modify_range` and `OverlayBonus` added to cards.zig
2. **Range modification** (4.3-4.7): Full implementation in apply.zig
   - `executeManoeuvreEffects()` processes manoeuvre cards
   - `executeAgentManoeuvres()` finds modify_range effects
   - `applyRangeModification()` adjusts engagement.range with clamping
   - `adjustRange()` helper clamps to valid Reach values
   - `range_changed` event added to events.zig
   - Called from `world.processTick()` before `tickResolver.resolve()`
3. **Overlay infrastructure** (4.8): `getOverlayBonuses()` and `AggregatedOverlay` in resolution.zig
   - Added `time_start`, `time_end` fields to `AttackContext`
   - Updated tick.zig to pass timing info

### Completed (continued)
4. **Overlay integration** (4.9-4.10): Bonuses now affect combat resolution
   - `resolveOutcome()` applies `to_hit_bonus` from attacker overlays → `resolution/outcome.zig:119`
   - `resolveOutcome()` applies `defense_bonus` from defender overlays → `resolution/outcome.zig:130`
   - `resolveTechniqueVsDefense()` applies `damage_mult` after packet creation → `resolution/outcome.zig:196`
   - Added `time_start`, `time_end` to `DefenseContext` → `resolution/context.zig:33-34`
   - `tick/resolver.zig:229-231` passes attack timing to DefenseContext
   - `getOverlayBonuses()` uses `getConst()` for const-correctness → `resolution/context.zig:162`

> **Decomposition note**: During this work, the codebase was refactored (see `doc/decomposition.md`).
> Resolution code moved from `resolution.zig` → `resolution/outcome.zig` and `resolution/context.zig`.
> The old `resolution.zig` is now a thin re-export module. Same pattern for tick/, apply/, combat/.

### Completed: Stationary Condition (4.11-4.17)
5. **Stationary condition** wired into resolution:
   - Added `.stationary` to `damage.Condition` enum → `damage.zig:90`
   - Added `hasFootworkInTimeline()` helper → `combat/plays.zig:355`
   - Added `engagement` and `is_stationary` fields to `DefenseContext` → `resolution/context.zig:35-36`
   - `CombatModifiers.forAttacker` now uses `activeConditions()` iterator → `resolution/context.zig:53-97`
   - `CombatModifiers.forDefender` now uses iterator + checks `is_stationary` → `resolution/context.zig:99-152`
   - Resolver computes `defender_stationary` from timeline → `tick/resolver.zig:171-177`
   - Also wired computed conditions: `.unbalanced`, `.pressured`, `.weapon_bound` now affect combat modifiers

> **Design deviation**: Original plan threaded timeline through ConditionIterator, but this would
> also require registry (for channel lookup). Simpler to compute `is_stationary` at resolver level
> and pass as flag on DefenseContext. Keeps iterator focused on agent/engagement state.

### Completed: Manoeuvre Cards (4.18-4.20)
6. **Manoeuvre card templates** added:
   - Added `TechniqueID.{advance, retreat, sidestep, hold}` → `cards.zig:224-228`
   - Added technique entries with `.footwork` channel and overlay bonuses → `card_list.zig:184-244`
   - Added card templates `t_advance`, `t_retreat`, `t_sidestep`, `t_hold` → `card_list.zig:404-496`
   - Added to `BaseAlwaysAvailableTemplates` → `card_list.zig:508-512`

### Next Steps
- 4.21-4.22: Contracts (UI verification)
- 4.23-4.31: Tests

### Build Status
All tests pass. Build clean.

---

**Created**: 2026-01-06
**Preflight**: 2026-01-06
**Last update**: 2026-01-06 (4.18-4.20 complete)
