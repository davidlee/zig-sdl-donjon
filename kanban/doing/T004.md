# T004: Manoeuvres

**Status**: doing
**Phase**: 4 of 6 (Timing/Simultaneity/Positioning)
**Design Doc**: `doc/timing_simultaneity_positioning.md`
**Depends on**: T003 (Targeting & Range) - COMPLETE

## Goal

Footwork cards that change positioning; overlay synergies with weapon techniques.

## Design Decisions

### Focal Targeting

Manoeuvres use `.single` targeting. The target identifies the "focal" engagement
for range modification. When unspecified, defaults to first weapon technique's
target on timeline, or first engagement.

### Overlay Bonuses

Rather than expressing overlay synergy through the card rules system, manoeuvres
declare bonuses as technique metadata. Resolution code aggregates bonuses from
overlapping manoeuvres via a dedicated `getOverlayBonuses()` helper (keeps
`CombatModifiers` focused on conditions).

```zig
pub const OverlayBonus = struct {
    offensive: struct {
        to_hit_bonus: f32 = 0,
        damage_mult: f32 = 1.0,
    } = .{},
    defensive: struct {
        defense_bonus: f32 = 0,
    } = .{},
};
```

### Range Propagation

`modify_range.propagate` implements spatial coherence for multi-engagement:
- Advancing n steps toward focal also advances n-1 toward other far enemies
- Retreating n steps from focal also retreats n-1 from other close enemies
- No-op in single engagement (current state); activates in Phase 5

### Manoeuvre Resolution Timing

Manoeuvre effects (range modification) execute **before** `tickResolver.resolve()`
so that attacks use updated range for validation. This is achieved by calling
`executeManoeuvreEffects()` before combat resolution in `world.resolveTick()`.

### Standing Still as Computed Condition

Rather than bespoke resolution logic, `.stationary` is a computed condition
(like `.pressured`, `.unbalanced`). This requires wiring computed conditions
into resolution properly — currently only stored conditions are checked.

- Add `.stationary` to `damage.Condition`
- Compute when agent has no footwork in their timeline this tick
- Update resolution to use `activeConditions()` iterator
- Effect: +10% hit chance for attacker against stationary defender

### Effect Target Context (Preflight finding)

Current `applyResolveEffect` takes `agent: *Agent`, but `modify_range` needs an
**engagement** target. Solution: Add `applyEngagementEffect` alongside existing
agent-targeted effect application.

## Tasks

### Domain: New Types

- [x] 4.1 Add `Effect.modify_range: struct { steps: i8, propagate: bool = true }`
- [x] 4.2 Add `OverlayBonus` struct to `Technique`

### Domain: Range Modification

- [x] 4.3 Add `applyEngagementEffect()` in apply.zig for engagement-targeted effects
- [x] 4.4 Implement `modify_range` handling: adjust `engagement.range` by steps (clamped)
- [x] 4.5 Add `executeManoeuvreEffects()` — processes manoeuvre cards before combat resolution
- [x] 4.6 Call `executeManoeuvreEffects()` in `world.processTick()` before `tickResolver.resolve()`
- [x] 4.7 Propagate logic stub (no-op for single engagement, ready for Phase 5)

### Domain: Overlay Bonuses

- [x] 4.8 Add `getOverlayBonuses()` helper in resolution.zig — scans timeline for overlapping manoeuvres
- [x] 4.9 Integrate overlay bonuses into attack resolution (to_hit, damage_mult)
- [x] 4.10 Integrate overlay bonuses into defense resolution (defense_bonus)

### Domain: Stationary Condition

- [ ] 4.11 Add `.stationary` to `damage.Condition` enum
- [ ] 4.12 Add optional `timeline: ?*const Timeline` param to `ConditionIterator.init` (default null)
- [ ] 4.13 Update `Agent.activeConditions()` to accept optional timeline
- [ ] 4.14 Compute `.stationary` when timeline provided and no footwork channel used
- [ ] 4.15 Update `CombatModifiers.forAttacker` to use `activeConditions()` iterator
- [ ] 4.16 Update `CombatModifiers.forDefender` to use `activeConditions()` iterator
- [ ] 4.17 Handle `.stationary` in defender switch: `mods.hit_chance += 0.10`

### Content: Manoeuvre Cards

- [ ] 4.18 Create manoeuvre templates in `card_list.zig`:
  - `advance`: close 1 step, overlay +10% damage to offensive
  - `retreat`: open 1 step, overlay +0.1 defense to defensive
  - `sidestep`: no range change, overlay +5% to_hit to offensive
  - `hold`: no movement, stamina recovery (stationary penalty applies)
- [ ] 4.19 Add `.footwork` channel to manoeuvre techniques
- [ ] 4.20 Add manoeuvres to `always_available` pool

### Contracts (for UI)

- [ ] 4.21 Verify `Command.play_card` handles footwork cards correctly
- [ ] 4.22 Document UI contract for footwork placement (timeline positioning deferred)

### Tests

- [ ] 4.23 `modify_range` adjusts engagement.range correctly
- [ ] 4.24 Range clamped at boundaries (can't go below .clinch or above .far)
- [ ] 4.25 Footwork overlaps weapon channel (no conflict)
- [ ] 4.26 `getOverlayBonuses` aggregates from multiple overlapping manoeuvres
- [ ] 4.27 Overlay damage bonus applied in attack resolution
- [ ] 4.28 `.stationary` computed when no footwork in timeline
- [ ] 4.29 `.stationary` NOT computed when footwork present
- [ ] 4.30 Stationary defender: +10% hit chance for attacker
- [ ] 4.31 Computed conditions (pressured, unbalanced) now affect resolution

## Pool Manoeuvres

| Card | Range Effect | Overlay Bonus | Cost |
|------|--------------|---------------|------|
| Advance | Close 1 step | +10% damage to offensive | 1.5 stam, 0.3s |
| Retreat | Open 1 step | +0.1 defense to defensive | 1.0 stam, 0.2s |
| Sidestep | None | +5% to_hit to offensive | 1.5 stam, 0.2s |
| Hold | None | None (stationary penalty applies) | 0 stam, 0.3s |

## Sequence

```
1. Types (4.1-4.2)
   |
   +---> 2. Range modification (4.3-4.7)
   |
   +---> 3. Overlay bonuses (4.8-4.10)
   |
   +---> 4. Stationary condition (4.11-4.17)
   |
   v
5. Manoeuvre cards (4.18-4.20) — needs types + effects wired
   |
   v
6. Contracts & tests (4.21-4.31)
```

Steps 2, 3, 4 can proceed in parallel after step 1.

## Acceptance Criteria

- [ ] Advance closes range by 1 step
- [ ] Footwork overlaps weapon channel in timeline
- [ ] Advance + thrust gives +10% damage
- [ ] Sidestep + thrust gives +5% to_hit
- [ ] Retreat + block gives +0.1 defense
- [ ] Stationary defender = +10% hit chance for attacker
- [ ] Computed conditions (pressured, unbalanced, weapon_bound) now affect resolution
- [ ] Manoeuvres available in always_available pool

## Key Files

```
src/domain/damage.zig         # Condition.stationary
src/domain/cards.zig          # Effect.modify_range, OverlayBonus on Technique
src/domain/card_list.zig      # manoeuvre templates
src/domain/combat.zig         # ConditionIterator timeline param
src/domain/apply.zig          # applyEngagementEffect, executeManoeuvreEffects
src/domain/resolution.zig     # getOverlayBonuses, activeConditions() usage
src/domain/world.zig          # resolveTick ordering
```

## Preflight Notes (2026-01-06)

### Code Context Reviewed
- `Effect` union (cards.zig:271-291)
- `Technique` struct (cards.zig:229-261)
- `ConditionIterator` (combat.zig:1230-1275)
- `CombatModifiers.forAttacker/forDefender` (resolution.zig:56-142)
- `applyResolveEffect` (apply.zig:1588-1634)
- `executeResolvePhaseRules` (apply.zig:1517)
- `TickResolver.resolve` (tick.zig:179-256)
- `Reach` enum (combat.zig:24-36)
- `damage.Condition` enum (damage.zig:52-86)

### Key Findings
1. Resolution uses `.conditions.items` directly — computed conditions not wired in
2. `applyResolveEffect` only handles agent targets — need engagement target path
3. `executeResolvePhaseRules` runs after `tickResolver.resolve()` — manoeuvres need earlier execution
4. Timeline accessible via `enc.stateFor(agent.id).current` during resolution

---

## Implementation Progress (2026-01-06)

### Completed
1. **Types** (4.1-4.2): `Effect.modify_range` and `OverlayBonus` added to cards.zig
2. **Range modification** (4.3-4.7): Full implementation in apply.zig
   - `executeManoeuvreEffects()` processes manoeuvre cards
   - `executeAgentManoeuvres()` finds modify_range effects
   - `applyRangeModification()` adjusts engagement.range with clamping
   - `adjustRange()` helper clamps to valid Reach values
   - `range_changed` event added to events.zig
   - Called from `world.processTick()` before `tickResolver.resolve()`
3. **Overlay infrastructure** (4.8): `getOverlayBonuses()` and `AggregatedOverlay` in resolution.zig
   - Added `time_start`, `time_end` fields to `AttackContext`
   - Updated tick.zig to pass timing info

### Completed (continued)
4. **Overlay integration** (4.9-4.10): Bonuses now affect combat resolution
   - `resolveOutcome()` applies `to_hit_bonus` from attacker overlays
   - `resolveOutcome()` applies `defense_bonus` from defender overlays (reduces hit chance)
   - `resolveTechniqueVsDefense()` applies `damage_mult` after damage packet creation
   - Added `time_start`, `time_end` to `DefenseContext` for defender overlay lookup
   - tick.zig passes attack timing to DefenseContext (defender's manoeuvres during attack)
   - Fixed `getOverlayBonuses()` to use `getConst()` for const-correct registry access

### Next Steps
- 4.11-4.17: Stationary condition (separate stream)
- 4.18-4.20: Manoeuvre card templates
- 4.21-4.31: Tests and contracts

### Build Status
All tests pass. Build clean.

---

**Created**: 2026-01-06
**Preflight**: 2026-01-06
**Last update**: 2026-01-06 (4.9, 4.10 complete)
