# T003: Targeting & Range

**Status**: doing
**Phase**: 3 of 6 (Timing/Simultaneity/Positioning)
**Design Doc**: `doc/timing_simultaneity_positioning.md` (lines 1521-1606 for new findings)
**Depends on**: T002 (Timeline Structure) - COMPLETE

## Goal

Range-aware targeting; ensure plays track their target and range predicates are evaluated.

## Design Decision: Use Existing Primitives

**Original plan** proposed new types:
- `TargetingMode` enum on Technique
- `ReachRequirement` struct on Technique and weapon.Template
- `targeting.zig` with new query functions

**Revised approach** after code review:

These primitives already exist and should be reused:

| Need | Existing Primitive | Location |
|------|-------------------|----------|
| Range validation | `Predicate.range` | cards.zig:146 |
| Weapon reach check | `Predicate.weapon_reach` | cards.zig:145 |
| Target selection | `TargetQuery` | cards.zig:160-169 |
| Weapon reach data | `weapon.Offensive.reach` | weapon.zig:57 |
| Engagement range | `Engagement.range` | combat.zig:704 |

**Rationale**:
- Cards already have `rules: []const Rule` with `valid: Predicate`
- `Predicate.range` can express "must be at sabre range or closer"
- `TargetQuery` already has `single`, `all_enemies`, `self`, etc.
- Adding parallel type systems creates confusion and maintenance burden

## Design Decision: Melee Reach Validation

**Approach chosen**: Implicit validation via `.melee` tag.

Rather than encoding reach checks into every technique card via predicates, `.melee` cards
are automatically validated against engagement range in `validateCardSelection`:

1. Get card's technique and its `attack_mode` (.thrust/.swing)
2. Get weapon's offensive mode for that attack type
3. Check if `weapon_mode.reach >= engagement.range` for ANY enemy (Option A: short-circuit true)

**Key insight**: The `Reach` enum uses weapon reaches (.clinch through .spear) for actual distances.
The abstract distances (.near, .medium, .far) represent distances BEYOND melee weapon reach,
requiring manoeuvres (Phase 4) to close before attacking.

## Current State

**Done**:
- [x] `Play.target: ?entity.ID` field added (combat.zig:709)
- [x] `Armament.getOffensiveMode(AttackMode)` helper (combat.zig:79-94)
- [x] `Encounter.getEngagementConst` / `getPlayerEngagementConst` (combat.zig:434-447)
- [x] `World.encounterPtr()` / `encounterPtrConst()` helpers (world.zig:303-310)
- [x] `validateMeleeReach()` validates melee cards against engagement range (apply.zig:816-841)
- [x] `validateCardSelection` takes optional encounter parameter (apply.zig:762-812)
- [x] All callers updated to pass encounter context
- [x] Tests for melee reach validation (apply.zig:1889-1979)
- [x] Removed unused `Agent.canPlayCardInPhase` method

**Not needed** (existing primitives sufficient):
- ~~TargetingMode~~ → use `TargetQuery`
- ~~ReachRequirement~~ → implicit via `.melee` tag + technique.attack_mode
- ~~weapon.Template.effective_range~~ → use `weapon.Offensive.reach`
- ~~targeting.zig~~ → predicates handle this

## Remaining Tasks

### 3.3 Content: Add range predicates to cards (optional)

Explicit `.range` predicates can still be added for special cases:
```zig
// Example: technique only valid at close range
.rules = &.{.{
    .trigger = .on_play,
    .valid = .{ .range = .{ .op = .lte, .value = .dagger } },
    // ...
}},
```

Note: For standard melee techniques, the implicit `.melee` tag validation handles
range checks automatically based on weapon reach.

### 3.4 (Deferred) Starting range calculation

Encounters currently start at `.far`. Could calculate from weapon reaches, but:
- Manoeuvres (Phase 4) will let players close distance
- Not blocking for basic range validation
- Defer to later phase

### 3.5 Play.target population

When plays are created, `Play.target` should be populated. Currently always `null`.
May need UI support for target selection.

## Acceptance Criteria

- [x] Melee cards validated against weapon reach / engagement range
- [x] `validateCardSelection` has encounter context for range checks
- [ ] `Play.target` populated when plays are created (deferred)
- [ ] At least one technique card has explicit range predicate (optional)

## Key Files

| File | Status | Changes |
|------|--------|---------|
| `src/domain/combat.zig` | Done | `Play.target`, `Armament.getOffensiveMode`, `Encounter.*Const` methods |
| `src/domain/world.zig` | Done | `encounterPtr()`, `encounterPtrConst()` helpers |
| `src/domain/apply.zig` | Done | `validateMeleeReach`, encounter param on `validateCardSelection` |
| `src/domain/ai.zig` | Done | Updated to pass encounter context |
| `src/presentation/views/combat/view.zig` | Done | Updated to pass encounter context |

## Design Decisions

1. **Use existing predicates** — No new TargetingMode or ReachRequirement types.

2. **Implicit melee validation** — `.melee` cards automatically checked via `validateMeleeReach()`.

3. **Option A for multi-enemy** — Short-circuit true on first enemy in range.

4. **Reach enum semantics** — Weapon reaches (.clinch-.spear) for actual distances;
   abstract distances (.near-.far) represent "beyond melee range, needs manoeuvres".

---

## Addendum: Design Debt to Address

### 1. Pointer Extraction Helpers

`World.encounterPtr()` / `encounterPtrConst()` exist because:
- `World.encounter: ?Encounter` (optional value)
- `validateCardSelection` wants `?*const Encounter` (optional pointer)

**Cleanup options:**

A. **Heap-allocate encounter**: Change `World.encounter` to `?*Encounter`
   - Cleaner pointer semantics throughout
   - Encounter lifecycle managed explicitly
   - Bigger refactor

B. **Pass World to validation**: `validateCardSelection(..., world: *const World)`
   - Validation accesses `world.encounter` internally
   - Increases coupling to World
   - Simpler change

C. **Keep helpers, localize pattern**
   - At minimum, document that callers use these helpers
   - Less ideal but contained

### 2. Semantic Distinction: "Not needed" vs "Not available"

Currently `encounter: ?*const Encounter = null` conflates:
- Card doesn't need encounter (self-target, buff)
- Caller doesn't have encounter access (bug/limitation)

**Cleanup options:**

A. **Two validation paths**:
```zig
validateSelfTargetCard(actor, card, phase)        // no encounter needed
validateTargetedCard(actor, card, phase, encounter) // encounter required
```

B. **Tagged context**:
```zig
const EncounterContext = union(enum) {
    not_applicable,                // self-target cards
    available: *const Encounter,   // encounter-targeted cards
};
```

C. **Card declares needs** (recommended):
   - Check `template.target_query` to determine if encounter is required
   - If `.single_enemy` / `.all_enemies` and no encounter → error, not silent skip
   - Card already knows its targeting needs; validation should enforce them

### Files to clean up when addressing:
- `src/domain/world.zig`: `encounterPtr()`, `encounterPtrConst()`
- `src/domain/apply.zig`: `validateCardSelection` signature
- All callers passing encounter context

---

**Created**: 2026-01-06
**T002 Completed**: 2026-01-06
**Play.target added**: 2026-01-06
**Melee reach validation**: 2026-01-06
