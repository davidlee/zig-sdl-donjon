# T013: Adrenaline Surge/Crash
Created: 2026-01-08

## Problem statement / value driver

First significant wound should trigger adrenaline response: temporary boost + pain suppression, followed by crash.

### Scope - goals

- Adrenaline surge condition on first significant wound
- Surge→crash transition on expiry
- Pain condition suppression during surge
- Data-driven condition metadata (not special-case code)

### Scope - non-goals

- Dud card injection (T015)

## Background

### Relevant documents

- `doc/trauma_wounds_conditions_ph2.md` (Phase 4.4)
- Architectural Alignment Review section

### Key files

- `src/domain/damage.zig` (Condition enum, penalties, new condition_meta table)
- `src/domain/combat/agent.zig` (ConditionIterator, condition tick processing)
- `src/domain/resolution/outcome.zig` (wound application path)

### Existing systems

- Conditions already have expiration (ticks, permanent, dynamic)
- Condition tick processing already handles expiry
- Pattern: data tables over imperative branches

## Changes Required

### 1. Add conditions + penalties (`damage.zig`)

```zig
// Condition enum
adrenaline_surge,
adrenaline_crash,

// condition_penalties
.adrenaline_surge => .{ .hit_chance = 0.05 },
.adrenaline_crash => .{ .hit_chance = -0.10, .defense_mult = 0.85, .footwork_mult = 0.85 },
```

### 2. Add condition metadata table (`damage.zig`)

```zig
pub const ConditionMeta = struct {
    on_expire: ?Condition = null,
    on_expire_duration: ?f32 = null,
    suppresses: []const ResourceAccessor = &.{},
};

pub const condition_meta = init: {
    var table: [@typeInfo(Condition).@"enum".fields.len]ConditionMeta =
        .{.{}} ** @typeInfo(Condition).@"enum".fields.len;

    table[@intFromEnum(Condition.adrenaline_surge)] = .{
        .on_expire = .adrenaline_crash,
        .on_expire_duration = 12.0,
        .suppresses = &.{.pain},
    };

    break :init table;
};
```

### 3. Trigger surge on first significant wound

In `outcome.zig`, after applying wound:

```zig
if (result.wound.worstSeverity().isAtLeast(.inhibited)) {
    if (!attack.defender.hasCondition(.adrenaline_surge) and
        !attack.defender.hasCondition(.adrenaline_crash)) {
        attack.defender.addCondition(.adrenaline_surge, .{ .ticks = 8.0 });
    }
}
```

### 4. Condition expiry checks metadata

In condition tick processing, when a condition expires:

```zig
const meta = damage.condition_meta[@intFromEnum(expired_condition)];
if (meta.on_expire) |successor| {
    agent.addCondition(successor, .{ .ticks = meta.on_expire_duration.? });
}
```

### 5. ConditionIterator checks suppression

Before yielding resource conditions, check if any active condition suppresses that resource:

```zig
fn isResourceSuppressed(self: *ConditionIterator, resource: ResourceAccessor) bool {
    var iter = self.agent.activeConditions();
    while (iter.next()) |ac| {
        const meta = damage.condition_meta[@intFromEnum(ac.condition)];
        for (meta.suppresses) |suppressed| {
            if (suppressed == resource) return true;
        }
    }
    return false;
}
```

## Test / Verification Strategy

### success criteria / ACs

- [ ] First `.inhibited` wound triggers `.adrenaline_surge`
- [ ] Second wound does not re-trigger surge
- [ ] Surge provides +0.05 hit_chance
- [ ] Pain conditions not yielded while surge active
- [ ] After 8 ticks, surge expires and crash begins
- [ ] Crash lasts 12 ticks with penalties
- [ ] Build passes, tests pass, lint clean

### unit tests

- Test surge trigger conditions
- Test suppression of pain conditions
- Test surge→crash transition
- Test crash expiry

## Quality Concerns / Risks

- **Ordering**: Suppression check must happen before resource condition yield
- **State tracking**: Need to ensure surge/crash don't overlap

## Progress Log / Notes

Architectural approach: condition metadata table handles transitions and suppression declaratively.
