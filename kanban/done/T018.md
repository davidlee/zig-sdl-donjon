# T018: Condition Definition & Computed-State Framework
Created: 2026-01-08

## Problem statement / value driver

Pain/trauma (T012) and future systems need reliable computed conditions with events, metadata, and engagement-aware querying. The current iterator is hard-coded, emits no events for relational states, and `ActiveCondition` lacks payloads, making it painful to extend.

### Scope - goals

- Introduce a declarative condition definition table driving `ConditionIterator`.
- Add condition caches + event emission so computed states (including engagement-dependent ones) fire `condition_applied/expired`.
- Extend `ActiveCondition` payloads to support metadata (DoTs, FSM sequences, ratios).
- Update agent APIs so `hasCondition`/predicates can observe computed states.
- Provide immediate support for T012’s pain/trauma thresholds without custom logic.

### Scope - non-goals

- No new condition content beyond wiring what already exists plus providing slots for T012.
- No UI/log copy changes beyond existing event payloads (handled separately).

## Background

### Relevant documents

- `doc/trauma_wounds_conditions_ph2.md` (Phase 2 + revised Increment 4 plan)
- `doc/issues/conditions.md` (current pain points and critiques)
- T012: Pain & Trauma Conditions (depends on this refactor)

### Key files

- `src/domain/damage.zig` (Condition enum + penalties)
- `src/domain/combat/agent.zig` (conditions storage + iterator)
- `src/domain/apply/event_processor.zig` (condition diffing/events)
- `src/domain/resolution/context.zig`, `src/domain/apply/effects/resolve.zig`

### Existing systems, memories, research, design intent

- Memories: `damage_conditions_overview`, `agents_system_overview`, `combat_resolution_overview`.
- Current iterator uses a `u4` phased switch and only emits computed events at end-of-turn with no engagement context.

## Changes Required

1. **ConditionDefinition table**: describe each condition’s computation type (resource threshold, engagement metric, encounter metric, stored), required context, and penalty metadata. `ConditionIterator` loops over this table.
2. **Condition cache + events**: maintain bitsets per agent (`internal`) and per engagement (`relational`). Update caches whenever underlying metrics change (blood drain, engagement pressure updates, positioning contests, etc.) and emit `condition_applied/expired`.
3. **ActiveCondition payloads**: upgrade to `ConditionState { condition, expiration, payload, source }` with a payload union for DoTs/stages/stacks. Update add/remove/tick + log formatting accordingly.
4. **API unification**: extend `Agent.hasCondition(condition, ctx?)` to consult computed states; provide helper contexts for cards/UI; ensure predicates and validation can reference computed conditions.
5. **Refactor consumers**: update `CombatModifiers`, `positioning`, etc. to use the new iterator/cache results; ensure `condition_penalties` integration unaffected.

### Challenges / Tradeoffs / Open Questions

- Where to store per-engagement caches (on engagement vs agent map)? Likely attach to `Engagement` for enemy-specific states.
- Need to ensure cache updates hook into all sources of metric changes (blood loss, engagement pressure, body capability changes).
- Payload design must stay lean for simple conditions while supporting richer data.

### Decisions

- Use `std.bit_set.StaticBitSet(@typeInfo(Condition).enum_fields.len)` for caches to avoid array caps.
- Represent condition computations via tagged union (e.g., `.resource { accessor, thresholds }`, `.engagement { metric, cmp }`, `.timeline { tag }`, `.stored`).

### Implications

- Simplifies T012/T013/T015 by letting them register new condition definitions instead of editing code.
- Enables future DoTs/state machines without bespoke plumbing.
- Provides consistent event/log/UI signaling for computed states.

## Tasks / Sequence of Work

1. Introduce `ConditionDefinition` module + data-driven iterator (no behavior change yet).
2. Implement condition caches + event emission for existing computed states (internal + engagement); update `event_processor` diffing to use caches.
3. Extend `ActiveCondition` to `ConditionState` with payload/source; adapt storage, add/remove, logging.
4. Update `Agent.hasCondition` & card predicates to include computed states via new API.
5. Document new APIs/memories; unblock T012 to add pain/trauma definitions using the table.

## Test / Verification Strategy

### success criteria / ACs

- Build/tests pass; existing condition-related tests updated.
- Computed conditions (balance/blood/pressure) emit `condition_applied/expired` when their metrics cross thresholds.
- `hasCondition` + predicates observe computed states.
- T012 can add new conditions solely by populating definitions.

### unit tests

- Iterator over definition table returns expected sequence (stored + computed).
- Condition cache diff emits events when thresholds crossed and suppresses duplicates.
- Payload serialization/log output validated for basic cases.

### integration tests

- Combat resolution tests ensure modifiers still apply; condition log entries appear for computed states.
- Positioning or engagement tests confirm relational conditions update per engagement.

### user acceptance

- Designers can add pain/trauma definitions without editing code; logs show condition changes as expected during playtest.

## Quality Concerns / Risks / Potential Future Improvements

- Need to ensure cache sync doesn’t regress performance; consider batching updates per tick.
- Payload system should remain backward compatible for stored conditions without metadata.
- Future: expose condition metadata to UI (tooltips, intensity) once payload plumbing proven.

## Progress Log / Notes

- Blocks lifted: T012 depends on this refactor; land T018 first.
- 2026-01-08: Design doc drafted at `doc/artefacts/T018_condition_framework_design.md`
- 2026-01-08: Design review complete. Key decisions:
  - `cards.Comparator` with explicit `.compare()` method for self-describing thresholds
  - `ComputationType.any` for composite triggers (mirrors `Predicate.any`)
  - Internal conditions cached on Agent; relational/positional computed on-demand
  - Comptime validation of table ordering invariant
  - 7-phase migration path including combat modifiers integration
- 2026-01-08: Implementation complete (Phases 1-6):
  - Added `Comparator.compare()` method to `cards.zig`
  - Created `src/domain/condition.zig` with all core types:
    - `ConditionDefinition`, `ComputationType`, `Category`
    - `ConditionPayload`, `ConditionState`, `ConditionScope`
    - `ConditionBitSet`, `ConditionCache` with `EvalContext`
    - `condition_definitions` table with comptime ordering validation
  - Replaced `ConditionIterator` in `agent.zig` with table-driven version
  - Added `condition_cache` field to Agent with invalidation API
  - Updated `hasCondition` to consult cache; added `hasConditionWithContext`
  - Added helper methods: `getResourceRatio`, `getSensoryScore`, `buildEvalContext`
  - Event emission via `emitConditionDiff` when cache recomputed
  - 6 new tests added (4 in condition.zig, 2 in agent.zig)
  - All 199 tests pass; code formatted and linted
