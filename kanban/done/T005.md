# T005: Multi-Opponent

**Status**: doing
**Phase**: 5 of 6 (Timing/Simultaneity/Positioning)
**Design Doc**: `doc/timing_simultaneity_positioning.md`
**Depends on**: T004 (Manoeuvres) - COMPLETE

## Goal

Attention system; flanking; positioning contests between combatants.

## Design Decisions

### Primary Target Heuristics
First `.single` targeting action of turn sets `attention.primary`. Subsequent `.single` cards auto-target same enemy. (Future: Focus cost to switch mid-turn - deferred.)

### Flanking as Computed Condition
Like `.stationary`, flanking is a computed condition yielded by `ConditionIterator`. Add `.flanked` and `.surrounded` to `damage.Condition` enum. Threshold: `engagement.position < 0.35` indicates enemy has angle advantage.

### Positioning Contest Stats
Score = Speed (0.3) + engagement.position (0.4) + Balance (0.3). Standing still = -0.3 penalty.

### Range Propagation
Activate T004's stub in this task. Advancing n steps toward focal also advances n-1 toward other engagements.

## Tasks

### Domain: Attention System

- [x] 5.1 Add `AttentionState` struct to `plays.zig`:
  - `primary: ?entity.ID` - current focus target
  - `awareness: f32` - derived from `stats.acuity * 0.1`
  - `penaltyFor(target) -> f32` - returns 0 for primary, up to 0.2 for others
- [x] 5.1.1 Extend `AgentEncounterState` with `attention: AttentionState`
- [x] 5.1.2 Initialize attention from acuity when encounter starts

- [x] 5.2 Apply attention penalties in `resolution/context.zig`:
  - Added `attention_penalty: f32` to `AttackContext`
  - `CombatModifiers.forAttacker`: apply `hit_chance -= attention_penalty`
  - Wired in `tick/resolver.zig`: compute penalty via `state.attention.penaltyFor(defender.id)`

### Domain: Flanking

- [x] 5.3 Implement `assessFlanking` in `combat/encounter.zig`:
  - Added `FlankingStatus` enum to `engagement.zig`: `none`, `partial`, `surrounded`
  - Exported from `mod.zig`
  - `Encounter.assessFlanking(agent_id)` counts active engagements + position < 0.35
  - `active_count <= 1` -> none; `flanking >= 2 or active >= 3` -> surrounded

- [x] 5.4 Apply flanking effects via `ComputedCombatState` (revised design):
  - Added `.flanked`, `.surrounded` to `damage.Condition` enum
  - Created `ComputedCombatState` struct in `resolution/context.zig`
  - Refactored `DefenseContext.is_stationary` → `DefenseContext.computed.is_stationary`
  - Added `computed.flanking: FlankingStatus` field
  - Resolver computes flanking once per defender (has full encounter context)
  - `CombatModifiers.forDefender`: `.partial` -> dodge_mod -= 0.10; `.surrounded` -> dodge_mod -= 0.20, defense_mult *= 0.85
  - Note: `flank_back_chance` for hit location shift deferred (not critical for MVP)

### Domain: Positioning Contests

- [x] 5.5 Create `src/domain/apply/effects/positioning.zig`:
  - `ManoeuvreType` enum: advance, retreat, sidestep, hold
  - `ManoeuvreOutcome` enum: aggressor_succeeds, defender_succeeds, stalemate
  - `resolveManoeuvreConflict(aggressor, defender, aggressor_move, defender_move, engagement, rng) -> Outcome`
  - `calculateManoeuvreScore(agent, move, position) -> f32` using speed + position + balance
  - Added `Block.normalize(value)` to `stats.zig` for stat normalization (baseline: 10 → 1.0)

- [x] 5.6 Integrate contests into tick resolution:
  - [x] Add `resolvePositioningContests(world)` in `apply/effects/positioning.zig`
  - [x] Call after `executeManoeuvreEffects` in `world.processTick`
  - [x] Add `getAgentFootwork(agent, enc, registry) -> ?ManoeuvreType` helper
  - [x] Activate range propagation in `manoeuvre.zig` (was line 86 TODO)
  - [x] Add exports to `apply/mod.zig` and `apply.zig`
  - [x] Fix test `makeTestAgent` - weapon instance via `TestAgent` struct pattern
  - **Contest mechanics**: winner gets +1 bonus step + weapon reach floor

### Content: Multi-Opponent Manoeuvres

- [x] 5.7 Add manoeuvre cards in `card_list.zig`:
  - [x] `t_circle`: position bonus vs all (`.all_enemies`), `modify_position: 0.1`
  - [x] `t_disengage`: open range from all, `modify_range: { .steps = 1, .propagate = false }`
  - [x] `t_pivot`: switch primary + position bonus (`.single`), `set_primary_target` + `modify_position: 0.15`
- [x] 5.7.1 Added `Effect.modify_position: f32` to cards.zig
- [x] 5.7.2 Added `Effect.set_primary_target` to cards.zig
- [x] 5.7.3 Added `TechniqueID.circle`, `.disengage`, `.pivot` + TechniqueEntries
- [x] 5.7.4 Added effect handlers in `manoeuvre.zig` (applyPositionModification, applySetPrimaryTarget)
- [x] 5.7.5 Added `position_changed`, `primary_target_changed` events

### Tests

- [x] 5.8 AttentionState.init derives awareness from acuity
- [x] 5.9 CombatModifiers.forAttacker applies attention penalty for non-primary
- [x] 5.10 assessFlanking returns none/partial/surrounded correctly
- [x] 5.11 ComputedCombatState passes flanking to forDefender (revised from ConditionIterator)
- [x] 5.12 CombatModifiers.forDefender applies flanking penalties
- [x] 5.13 resolveManoeuvreConflict outcomes based on score differential
- [x] 5.14 Standing still loses positioning contest
- [~] 5.15 Range propagation applies n-1 steps to non-focal engagements
  - Skipped test added in `manoeuvre.zig` - needs multi-engagement encounter setup

## Acceptance Criteria

- Attacking non-primary target has penalty based on awareness
- Acuity improves awareness (finally useful!)
- Flanking detected with 2+ active engagements
- Positioning contests resolve advance vs retreat/sidestep
- Standing still loses positioning contest automatically

## Key Files

> **Note**: Codebase uses decomposed modules. Use symbol search.

```
src/domain/combat/plays.zig           # AttentionState, AgentEncounterState extension
src/domain/combat/engagement.zig      # assessFlanking, FlankingStatus
src/domain/combat/agent.zig           # ConditionIterator extension (phases 3,4)
src/domain/damage.zig                 # .flanked, .surrounded conditions
src/domain/resolution/context.zig     # CombatModifiers updates, AttackContext/DefenseContext
src/domain/tick/resolver.zig          # Wire attention into contexts
src/domain/apply/effects/positioning.zig  # NEW: positioning contests
src/domain/apply/effects/manoeuvre.zig    # Range propagation activation
src/domain/world.zig                  # processTick ordering
src/domain/card_list.zig              # New manoeuvre cards
```

## Sequence

```
5.1 AttentionState + 5.3 assessFlanking  (parallel, foundation)
       |                    |
       v                    v
5.2 Attention penalties    5.4 Flanking effects
       |                    |
       +--------------------+
                |
                v
         5.5 resolveManoeuvreConflict
                |
                v
         5.6 Contest integration + Range propagation
                |
                v
         5.7 Multi-opponent manoeuvres
                |
                v
         5.8-5.15 Tests
```

## Positioning Contest Outcomes

| Aggressor | Defender | Contest Type |
|-----------|----------|--------------|
| Advance | Retreat | Chase (speed vs speed) |
| Advance | Advance | Collision (who gets inside) |
| Advance | Sidestep | Angle (position vs agility) |
| Advance | Nothing | Auto-win (standing still penalty) |

## Multi-Opponent Manoeuvres

| Card | Effect | Implementation |
|------|--------|----------------|
| Circle | Position bonus vs all | `.all_enemies`, `modify_position` |
| Disengage | Open range from all | `.all_enemies`, `modify_range: {.steps=1, .propagate=false}` |
| Pivot | Switch primary + position bonus | `.single`, sets `attention.primary` |

## Unlocks

- Viable multi-opponent combat
- Acuity stat relevance
- Tactical depth in positioning

---

Architectural alignment review: T005 is aligned with the goal of strengthening card rules/primitives:

- All mechanics rely on existing data-driven structures. Attention, flanking, and positioning contests are implemented via new structs/functions but still feed into CombatModifiers,
  ConditionIterator, and Effect evaluations rather than bespoke one-off hacks. That keeps the rule system central.
- Tasks reference the decomposed modules (combat/plays.zig, resolution/context.zig, apply/effects/*) and introduce new Effect variants (modify_position, set_primary_target) instead of
  hardcoding behaviour. This reinforces the approach of enriching the primitives rather than bypassing them.
- The sequencing ensures foundational data (attention state, flanking detection) is built before applying it in modifiers or card content, reducing the temptation to add ad-hoc checks in
  effect execution.

Remaining considerations to keep everything rowing in the same direction:

1. When adding new effect variants (modify_position, set_primary_target), make sure they go through the same cards.Effect enum so future content can reuse them without extra code paths.
2. Positioning contests currently live in a forthcoming apply/effects/positioning.zig. Ensure their results are expressed as standard events/effects (e.g., range/position modifiers) so
    they integrate with cards that respond to those events.
3. Tests (5.8–5.15) should focus on verifying the rule layers (predicates, modifiers) rather than just end-to-end behaviour, keeping the primitives trustworthy.

In summary, T005 continues building atop the rule/effect system instead of sidestepping it, which supports the broader vision of a flexible, data-driven card engine. Stay mindful when
adding new primitives—document them and wire them through the existing expression/execution pipeline to avoid future special cases.

**Created**: 2026-01-06
**Preflight**: 2026-01-06