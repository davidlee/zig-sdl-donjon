# T009: Targeting & Range Validation Redesign

## Problem

Current validation rejects attacks at selection time if no enemy is in range. But with a timeline system, this is wrong:

- Player is out of range
- Player plays Advance (closes distance)
- Player wants to play Attack - but can't, because validation checks *current* range

Also doesn't handle opponent moving away after you've queued an attack.

## Current State (Wrong)

- [x] Attacks have `.target = .all_enemies` - legacy from before targeting was wired up
- [x] `validateMeleeReach` checks if *any* enemy is in range at selection time
- [x] Range is treated as a card validity predicate, not a targeting constraint

## Correct Model

### Validation Categories

**Hard invalid** (reject at selection):
- Channel conflict
- Can't afford costs (stamina/focus/time)
- Wrong phase
- Card requirements (e.g., no weapon equipped)

**Soft invalid** (allow, resolve dynamically):
- No valid targets *currently* - targeting is evaluated at resolution

### Targeting vs Validity

- `Rule.valid` → card-level predicates (weapon equipped, stance requirement)
- Targeting → finds valid targets at resolution time, range included

A melee attack with no targets in range isn't invalid - it just has an empty target set *right now*.

### Attack Flow

1. Advance (target: goblin) → `.single` target, sets primary target, closes range
2. Attack (target: .single) → inherits primary target, range checked at resolution

### Primary Target & Focus Cost

- Advance/Pivot set `attention.primary` to the targeted enemy
- Subsequent attacks default to primary target (no additional selection)
- Switching to a *different* target costs focus
- Primary target resets each turn

## Changes Required

1. [x] **Update attack cards**: `.all_enemies` → `.single` (except true multi-target attacks)
2. [x] **Remove selection-time range validation**: Call site removed, cards always selectable
3. [x] **Delete dead code**: `validateMeleeReach` removed from `validation.zig`
4. [x] **Add resolution-time range check**: In `TickResolver.resolve:170-191`, checks
   `actor.weapons.getOffensiveMode(technique.attack_mode).reach` vs `engagement.range`.
   If weapon reach < engagement range → emit `attack_out_of_range` event, skip resolution.
5. [x] **Handle whiff case**: Added `attack_out_of_range` event variant in `events.zig:138-144`

## Testing

### Integration Tests (in `src/testing/integration/domain/range_validation.zig`)
- `Attack at far range emits attack_out_of_range event` - verifies out-of-range detection
- `Attack at far range does not deal damage` - confirms no damage on whiff
- `Attack at close range resolves normally` - verifies in-range hits
- `Attack with longer reach weapon hits at medium range` - tests reach boundaries
- `Attack at dagger range with sabre weapon hits` - tests longer weapon at close range

### Harness additions
- `setPlayerFromTemplate()` - configure player from persona (name, stats, resources, armament)
- `setRange()` - manipulates engagement range for test scenarios
- `getEngagement()` - inspects engagement state

## UI Feedback for No Valid Targets

Cards that are playable but have no valid targets currently should render with a warning state
(not greyed/disabled, but visually distinct - e.g. orange border instead of green).

### Data Flow

```
Domain Events → CombatSnapshot (precomputed) → CardStatus → UI State → Render
```

### Option A: Naive (easy, wrong)

Query `targeting.filterByWeaponReach()` per card per frame in the view layer.

**Problem**: O(cards × enemies) per frame, called from render loop. Expensive and couples
presentation directly to domain internals.

### Option B: Precomputed DTO (right way)

1. **Extend `CardStatus`** in `combat_snapshot.zig`:
   ```zig
   pub const CardStatus = struct {
       card_id: entity.ID,
       playable: bool,          // hard validation (costs, phase, predicates)
       has_valid_targets: bool, // soft validation (melee has enemy in reach)
   };
   ```

2. **Compute in `populateCardStatuses()`**: For melee/ranged cards, check if any engagement
   satisfies `weapon_reach >= engagement.range`. Non-targeting cards get `has_valid_targets = true`.

3. **Cache invalidation**: Already implemented in `Coordinator`:
   - `cached_snapshot` holds the snapshot
   - `invalidateSnapshot()` clears cache
   - Called automatically when any domain events occur (coordinator.zig:166-168)
   - No changes needed here

4. **Extend UI `State`** in `card/model.zig`:
   ```zig
   pub const State = packed struct {
       // ...existing...
       warning: bool = false,  // playable but no valid targets currently
   };
   ```

5. **Set warning in view**: `warning = card.playable and !card.has_valid_targets`

6. **Render warning state**: Card renderer shows distinct visual (orange/yellow border,
   warning icon, etc.) when `state.warning == true`.

### Key Files

- `src/domain/query/combat_snapshot.zig` - CardStatus, populateCardStatuses()
- `src/presentation/views/card/model.zig` - State struct
- `src/presentation/views/card/data.zig` - Data struct (intermediate)
- `src/presentation/card_renderer.zig` - Visual rendering
- `src/presentation/views/combat/view.zig` - View model creation

### Tasks

6. [x] Extend `CardStatus` with `has_valid_targets: bool`
7. [x] Add target validity computation in `validateCards()` - uses new `targeting.hasAnyTargetInRange()`
8. [x] Add `warning: bool` to UI `State`
9. [x] Wire `warning` from CardStatus through to State
   - Extended `card/data.zig` Data struct with `has_valid_targets`
   - Updated `fromInstance()` signature to take 4th param
   - Added `CombatSnapshot.cardHasValidTargets()` query method
   - Added `View.cardHasValidTargets()` helper
   - Updated all card state creation sites in `combat/view.zig`
   - Fixed `card_renderer.zig` state hash (u6 → u7 for 7-bit packed struct)
10. [x] Render warning visual in card_renderer
11. [x] Integration test: card shows warning when out of range

## Progress Log

- 2026-01-08: Domain validation changes complete (tasks 1-5)
- 2026-01-08: Integration tests for range validation complete
- 2026-01-08: Replaced ad-hoc `equipPlayerSword()` with `setPlayerFromTemplate()` using personas
- 2026-01-08: UI data plumbing complete (tasks 6-9), compiles clean
- 2026-01-08: Render warning visual (task 10) and integration tests (task 11) complete
- **All tasks complete** - ready to move to done

### Implementation Summary

**Files modified for UI warning state:**
- `src/domain/apply/targeting.zig` - Added `hasAnyTargetInRange()` pub fn (~line 264)
- `src/domain/query/combat_snapshot.zig` - Extended `CardStatus`, added `cardHasValidTargets()`
- `src/presentation/views/card/data.zig` - Added `has_valid_targets` field
- `src/presentation/views/card/model.zig` - Added `warning` to `State` packed struct
- `src/presentation/views/combat/view.zig` - Wired `warning` in all card state creation sites
- `src/presentation/card_renderer.zig` - Fixed `stateToHash()` bit width, added orange border for warning state
- `src/testing/integration/harness.zig` - Added `getCardStatus()` helper for snapshot queries
- `src/testing/integration/domain/range_validation.zig` - Added UI warning state tests

**How it works:**
1. `CardStatus.has_valid_targets` is computed in snapshot for all player cards
2. `State.warning` is set when `playable && !has_valid_targets`
3. `stateBorderColor()` returns orange (255, 165, 0) when `state.warning == true`
4. Warning border renders at lower priority than selected/highlighted/target but higher than played