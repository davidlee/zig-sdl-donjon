# T003: Targeting & Range

**Status**: done
**Phase**: 3 of 6 (Timing/Simultaneity/Positioning)
**Design Doc**: `doc/timing_simultaneity_positioning.md` (lines 1521-1606 for new findings)
**Depends on**: T002 (Timeline Structure) - COMPLETE

## Goal

Range-aware targeting; ensure plays track their target and range predicates are evaluated.

## Design Decision: Use Existing Primitives

**Original plan** proposed new types:
- `TargetingMode` enum on Technique
- `ReachRequirement` struct on Technique and weapon.Template
- `targeting.zig` with new query functions

**Revised approach** after code review:

These primitives already exist and should be reused:

| Need | Existing Primitive | Location |
|------|-------------------|----------|
| Range validation | `Predicate.range` | cards.zig:146 |
| Weapon reach check | `Predicate.weapon_reach` | cards.zig:145 |
| Target selection | `TargetQuery` | cards.zig:160-169 |
| Weapon reach data | `weapon.Offensive.reach` | weapon.zig:57 |
| Engagement range | `Engagement.range` | combat.zig:704 |

**Rationale**:
- Cards already have `rules: []const Rule` with `valid: Predicate`
- `Predicate.range` can express "must be at sabre range or closer"
- `TargetQuery` already has `single`, `all_enemies`, `self`, etc.
- Adding parallel type systems creates confusion and maintenance burden

## Design Decision: Melee Reach Validation

**Approach chosen**: Implicit validation via `.melee` tag.

Rather than encoding reach checks into every technique card via predicates, `.melee` cards
are automatically validated against engagement range in `validateCardSelection`:

1. Get card's technique and its `attack_mode` (.thrust/.swing)
2. Get weapon's offensive mode for that attack type
3. Check if `weapon_mode.reach >= engagement.range` for ANY enemy (Option A: short-circuit true)

**Key insight**: The `Reach` enum uses weapon reaches (.clinch through .spear) for actual distances.
The abstract distances (.near, .medium, .far) represent distances BEYOND melee weapon reach,
requiring manoeuvres (Phase 4) to close before attacking.

## Current State

**Done**:
- [x] `Play.target: ?entity.ID` field added (combat.zig:709)
- [x] `Armament.getOffensiveMode(AttackMode)` helper (combat.zig:79-94)
- [x] `Encounter.getEngagementConst` / `getPlayerEngagementConst` (combat.zig:434-447)
- [x] `World.encounterPtr()` / `encounterPtrConst()` helpers (world.zig:303-310)
- [x] `validateMeleeReach()` validates melee cards against engagement range (apply.zig:816-841)
- [x] `validateCardSelection` takes optional encounter parameter (apply.zig:762-812)
- [x] All callers updated to pass encounter context
- [x] Tests for melee reach validation (apply.zig:1889-1979)
- [x] Removed unused `Agent.canPlayCardInPhase` method
- [x] `TargetQuery.single` simplified (removed `Selector`, reads from `Play.target`)
- [x] `TargetQuery.elected_n: u8` added for future multi-target selection
- [x] Target resolution functions accept `play_target: ?entity.ID` parameter
- [x] `sand_in_the_eyes` card updated: `.single` targeting + `.range` predicate
- [x] Tests for `.single` target resolution (apply.zig:2013-2089)
- [x] `CommittedAction.target` field propagates `Play.target` through commit phase
- [x] `PendingTarget` struct and `pending_targets` array on `TurnState`
- [x] `Command.play_card` accepts optional target
- [x] `playActionCard` stores pending target, `cancelActionCard` clears it
- [x] `buildPlaysForAgent` reads pending target into `Play.target`

**Not needed** (existing primitives sufficient):
- ~~TargetingMode~~ → use `TargetQuery`
- ~~ReachRequirement~~ → implicit via `.melee` tag + technique.attack_mode
- ~~weapon.Template.effective_range~~ → use `weapon.Offensive.reach`
- ~~targeting.zig~~ → predicates handle this

## Remaining Tasks

### 3.3 Content: Add range predicates to cards — DONE

`sand_in_the_eyes` now has `.valid = .{ .range = .{ .op = .lte, .value = .dagger } }`
and uses `.target = .single` for single-target selection.

### 3.4 (Deferred) Starting range calculation

Encounters currently start at `.far`. Could calculate from weapon reaches, but:
- Manoeuvres (Phase 4) will let players close distance
- Not blocking for basic range validation
- Defer to later phase

### 3.5 Play.target population — DOMAIN COMPLETE

Domain layer fully wired:
- `TargetQuery.single` reads from `Play.target` at resolution time
- `CommittedAction.target` propagates `Play.target` through commit phase
- Target resolution uses `action.target` in tick resolution

**Blocked on**: UI for target selection when playing cards. When plays are created,
`Play.target` needs to be set from player's selection.

## Acceptance Criteria

- [x] Melee cards validated against weapon reach / engagement range
- [x] `validateCardSelection` has encounter context for range checks
- [x] `TargetQuery.single` resolves from `Play.target` (domain layer ready)
- [x] At least one card has explicit range predicate (`sand_in_the_eyes`)
- [x] `Play.target` populated from `pending_targets` at commit phase (domain complete)
- [x] UI: target selection when playing `.single` cards
- [x] UI: target selection when adding `.single` cards in commit phase
- [x] Auto-targeting when single enemy (both selection and commit phases)

## Commit-Phase Targeting — COMPLETE

Playing a `.single` card during commit phase (via Focus/`commit_add`) now prompts for
target selection, matching selection-phase behavior.

**Changes made:**
- `Command.commit_add` → `commit_add: struct { card_id: ID, target: ?ID = null }`
- `CombatUIState.targeting_for_commit: bool` — distinguishes selection vs commit targeting
- `View.commitAddCard()` — mirrors `playCard()` for commit phase
- `View.completeTargeting()` — issues `commit_add` or `play_card` based on flag
- `CommandHandler.commitAdd()` — accepts target, stores as pending target
- Auto-targeting when single enemy (both phases)

## Key Files

| File | Status | Changes |
|------|--------|---------|
| `src/domain/combat.zig` | Done | `Play.target`, `PendingTarget`, `TurnState.pending_targets` + helpers |
| `src/commands.zig` | Done | `play_card` and `commit_add` now structs with optional target |
| `src/domain/world.zig` | Done | `encounter: ?*Encounter` (heap-allocated), removed `encounterPtr*()` helpers |
| `src/domain/cards.zig` | Done | `TargetQuery.single` (no payload), `elected_n: u8`, removed `Selector` |
| `src/domain/apply.zig` | Done | `validateMeleeReach`, encounter param, target resolution accepts `play_target`, new tests |
| `src/domain/tick.zig` | Done | `CommittedAction.target`, propagates `Play.target` through resolution |
| `src/domain/card_list.zig` | Done | `sand_in_the_eyes`: `.single` targeting + range predicate |
| `src/domain/ai.zig` | Done | Updated to pass encounter directly (no helper) |
| `src/presentation/views/combat/view.zig` | Done | UI targeting flow; `playCard`, `commitAddCard`, `completeTargeting` with auto-targeting |
| `src/presentation/view_state.zig` | Done | `CombatUIState.pending_target_card`, `targeting_for_commit`, `isTargeting()` helper |

## Design Decisions

1. **Use existing predicates** — No new TargetingMode or ReachRequirement types.

2. **Implicit melee validation** — `.melee` cards automatically checked via `validateMeleeReach()`.

3. **Option A for multi-enemy** — Short-circuit true on first enemy in range.

4. **Reach enum semantics** — Weapon reaches (.clinch-.spear) for actual distances;
   abstract distances (.near-.far) represent "beyond melee range, needs manoeuvres".

5. **TargetQuery.single semantics** — Removed compile-time `Selector` struct (hardcoded IDs
   don't make sense). `.single` now reads from `Play.target` at resolution time:
   - For validation: returns all enemies (any could be valid target)
   - For resolution: uses the specific `play_target` ID
   - `elected_n: u8` added for future "choose up to N enemies" support

---

## Addendum: Design Debt (Resolved)

### 1. Pointer Extraction Helpers — RESOLVED

**Problem**: `World.encounterPtr()` / `encounterPtrConst()` helpers existed to convert
`?Encounter` (optional value) to `?*const Encounter` (optional pointer) for validation.

**Solution**: Option A — Heap-allocate encounter.

Changed `World.encounter` from `?Encounter` to `?*Encounter`:
- `Encounter.init()` now returns `*Encounter` (heap-allocated)
- `Encounter.deinit()` now frees the allocation
- Removed `encounterPtr()` and `encounterPtrConst()` helpers
- ~35 call sites updated (mostly mechanical `&()` removal)

Benefits:
- Natural `?*Encounter` semantics throughout
- No helper functions needed
- Cleaner unwrap patterns: `world.encounter orelse return` (no address-of)
- `if (world.encounter) |enc|` directly yields pointer

### 2. Semantic Distinction: "Not needed" vs "Not available"

**Status**: Deferred — less urgent now that pointer semantics are clean.

The remaining issue (null conflates "not needed" vs "not available") can be
addressed later if it causes bugs. Current approach works for all known cases.

---

**Created**: 2026-01-06
**T002 Completed**: 2026-01-06
**Play.target added**: 2026-01-06
**Melee reach validation**: 2026-01-06
**Heap-allocated encounter**: 2026-01-06
**TargetQuery.single refactor**: 2026-01-06
**sand_in_the_eyes range predicate**: 2026-01-06
**CommittedAction.target wiring**: 2026-01-06
**pending_targets domain wiring**: 2026-01-06
**UI targeting flow**: 2026-01-06
**Range predicate wiring fix**: 2026-01-06
**Target in played_action_card event**: 2026-01-06
**Commit-phase targeting**: 2026-01-06
**Auto-targeting re-enabled**: 2026-01-06
**T003 Complete**: 2026-01-06

---

## Plan: Play.target Population (UI Integration)

### Problem

Cards go to `in_play` zone during selection phase, but `Play` objects aren't created until
`buildPlaysFromInPlayCards()` runs at commit phase entry. Need somewhere to stash the target
between `play_card` command and Play creation.

### Design

1. **Storage**: Bounded array on `TurnState` (no allocator, cleared with turn)
   ```zig
   const PendingTarget = struct { card_id: entity.ID, target_id: entity.ID };
   pending_targets: [Timeline.max_slots]?PendingTarget = .{null} ** Timeline.max_slots,
   ```

2. **Command change**: `play_card: ID` → `play_card: struct { card_id: ID, target: ?ID = null }`

3. **Flow**:
   - `playActionCard`: if target provided, store in `pending_targets`
   - `buildPlaysForAgent`: when creating Play, lookup pending target for card_id
   - `TurnState.clear`: pending_targets reset (already null-splatted)

4. **UI responsibility**:
   - For `.single` cards: prompt for target before sending `play_card` (or auto-assign if single enemy)
   - Changing targets in commit phase: future work (Focus cost)

5. **Invalid target handling**: noop at resolution - if target doesn't exist, `.single` returns empty

### Implementation Steps

- [x] Add `PendingTarget` struct and `pending_targets` array to `TurnState`
- [x] Add `setPendingTarget` / `getPendingTarget` / `clearPendingTarget` helpers
- [x] Modify `Command.play_card` to struct with optional target
- [x] Update `playActionCard` to store pending target
- [x] Update `buildPlaysForAgent` to read pending target into `Play.target`
- [x] Update `cancelActionCard` to clear pending target
- [x] Update all `play_card` command usages (UI)
- [x] UI: prompt for target when playing `.single` cards
- [x] UI: auto-assign target when single enemy

### UI Targeting Implementation

**View changes** (`src/presentation/views/combat/view.zig`):

1. **`playCard()`**: New helper checks if card `requiresSingleTarget()`:
   - Single enemy: auto-assigns target
   - Multiple enemies: enters targeting mode via `enterTargetingMode()`
   - No targeting needed: plays immediately

2. **`enterTargetingMode()`**: Sets `pending_target_card` in `CombatUIState`

3. **`completeTargeting()`**: When enemy clicked in targeting mode, plays the pending card with target

4. **`cancelTargeting()`**: Clears `pending_target_card` (ESC key or click elsewhere)

5. **`onClick()`**: Modified to:
   - Check if in targeting mode first (only allow enemy selection or cancel)
   - Call `playCard()` instead of `startCardAnimation()` for card clicks

6. **`handleKey()`**: ESC cancels targeting mode

**State changes** (`src/presentation/view_state.zig`):

- `CombatUIState.pending_target_card: ?entity.ID` — card awaiting target selection
- `CombatUIState.isTargeting()` — helper for targeting mode check

**Domain changes** (`src/domain/cards.zig`):

- `Template.requiresSingleTarget()` — checks if any expression uses `.single` targeting
- Test added for `requiresSingleTarget()`

**Bug fix** (`src/domain/apply.zig`):

- `evaluateValidityPredicate` previously returned `false` for `.range` predicates (TODO comment)
- Now properly evaluates range against player-enemy engagements
- `rulePredicatesSatisfied` now accepts optional `encounter` parameter
- All call sites updated to pass encounter context
