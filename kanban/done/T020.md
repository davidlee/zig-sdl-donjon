# T020: Integration Test Infrastructure
Created: 2026-01-08

## Problem statement / value driver

No infrastructure for testing multi-unit collaboration at various scales. Current tests are either pure unit tests or ad-hoc inline setups. Need a way to exercise flows like "play card → timeline → tick → events" without recreating the world from scratch in every test.

### Scope - goals

- Establish folder structure for integration tests organized by feature/layer.
- Create a lightweight harness for driving combat flows.
- Wire up `zig build test-unit` and `zig build test-integration` targets.
- Write first integration scenario(s) as proof of concept.

### Scope - non-goals

- System/E2E tests (full app running).
- Comprehensive integration coverage (just foundation + exemplar scenarios).
- Presentation layer integration tests (focus on domain first).

## Background

### Relevant documents

- `doc/issues/test_setup.md` - Full design doc with harness API (read it!)

### Key files

- `build.zig` - needs new test steps
- `Justfile` - needs new recipes
- T019 deliverables (`src/data/personas.zig`, `src/testing/fixtures.zig`)

### Existing systems, memories, research, design intent

- Memories: `combat_resolution_overview`, `timeline_hand_management_overview`, `events_system_overview`
- TurnPhase enum: `draw_hand`, `player_card_selection`, `commit_phase`, `tick_resolution`, `player_reaction`, `animating`

## Changes Required

### 1. Folder structure

```
src/testing/
  fixtures.zig          # (T019)
  integration/
    mod.zig             # imports all integration test modules
    domain/
      card_flow.zig     # play → timeline → tick → events
      damage_resolution.zig  # hit → armour → wound → conditions
      positioning.zig   # manoeuvres, range changes
    presentation/
      (future)
```

### 2. Integration Harness

```zig
// src/testing/integration/harness.zig
pub const Harness = struct {
    alloc: std.mem.Allocator,
    world: *World,

    pub fn init(alloc: Allocator, encounter: *const EncounterTemplate) !Harness
    pub fn deinit(self: *Harness) void

    // Card management
    pub fn giveCard(self: *Harness, agent: *Agent, name: []const u8) !entity.ID
    pub fn playCard(self: *Harness, card_id: entity.ID, target: ?entity.ID) !void
    pub fn stackModifier(self: *Harness, play_idx: usize, name: []const u8) !void
    pub fn cancelPlay(self: *Harness, play_idx: usize) !void

    // Phase control
    pub fn transitionTo(self: *Harness, phase: combat.TurnPhase) !void
    pub fn commitPlays(self: *Harness) !void
    pub fn resolveTick(self: *Harness) !void
    pub fn resolveAllTicks(self: *Harness) !void

    // Inspection
    pub fn player(self: *Harness) *Agent
    pub fn enemy(self: *Harness, idx: usize) *Agent
    pub fn getPlays(self: *Harness) []const combat.Play
    pub fn getTimeline(self: *Harness) *const combat.Timeline

    // Events
    pub fn expectEvent(self: *Harness, tag: events.EventTag) !void
    pub fn expectNoEvent(self: *Harness, tag: events.EventTag) !void
    pub fn drainEvents(self: *Harness) []const events.Event
};
```

### 3. Build targets

In `build.zig`:
```zig
const unit_step = b.step("test-unit", "Run unit tests");
// ... existing test setup

const integration_tests = b.addTest(.{
    .root_source_file = b.path("src/testing/integration/mod.zig"),
});
const integration_step = b.step("test-integration", "Run integration tests");
integration_step.dependOn(&b.addRunArtifact(integration_tests).step);

const all_tests = b.step("test", "Run all tests");
all_tests.dependOn(unit_step);
all_tests.dependOn(integration_step);
```

### 4. Justfile recipes

```just
test-unit:
  zig build test-unit

test-integration:
  zig build test-integration

test: test-unit test-integration
```

### 5. First scenarios (`card_flow.zig`)

- "Player plays thrust, resolves" → play created, committed, tick resolves, stamina deducted
- "Pool card clone lifecycle" → clone created from always_available, cooldown set, destroyed after resolution
- "Modifier stacking" → base card + modifier, verify both in play

### Challenges / Tradeoffs / Open Questions

- **Harness vs raw World**: Harness wraps common operations but tests can still access `world` directly for edge cases. Keep harness thin.
- **Event assertions**: Should `expectEvent` be strict (exact match) or loose (tag only)? Start with tag-based, can add payload matching later.
- **Phase transitions**: Some transitions trigger automatic processing (e.g., commit → tick). Harness methods should document what they trigger.

### Decisions

(to be filled during implementation)

### Implications

- Enables regression testing of gameplay flows without manual setup.
- New contributors can understand flows by reading integration tests.
- Foundation for future presentation/rendering integration tests.

## Tasks / Sequence of Work

1. [ ] Create `src/testing/integration/` folder structure
2. [ ] Implement `Harness` struct with init/deinit
3. [ ] Add card management methods (giveCard, playCard)
4. [ ] Add phase control methods (transitionTo, commitPlays, resolveTick)
5. [ ] Add inspection methods (player, enemy, getPlays, getTimeline)
6. [ ] Add event assertion methods
7. [ ] Write first scenario in `domain/card_flow.zig`
8. [ ] Update `build.zig` with test-unit/test-integration steps
9. [ ] Update `Justfile` with recipes
10. [ ] Document in `doc/testing.md`

## Test / Verification Strategy

### success criteria / ACs

- `zig build test-unit` runs existing unit tests.
- `zig build test-integration` runs integration tests.
- `just test` runs both.
- At least 3 integration scenarios pass in `card_flow.zig`.
- Harness API is ergonomic for writing new scenarios.

### unit tests

- Harness init/deinit doesn't leak.

### integration tests

- The scenarios themselves ARE the integration tests.

### user acceptance

- Writing a new scenario is straightforward: init harness, call methods, assert.

## Quality Concerns / Risks / Potential Future Improvements

- Keep harness methods simple; complex assertions can be helper functions outside the struct.
- Watch for test interdependence - each scenario should be fully isolated.
- Future: add `presentation/combat_log.zig` tests once domain foundation solid.
- Future: consider test filtering by tag/folder for faster iteration.

## Progress Log / Notes

- 2026-01-08: Task created from `doc/issues/test_setup.md`
- Depends on: T019 (personas & fixtures)
- 2026-01-08: Tests migrated from T019 (need Encounter/World setup):
  - `validateMeleeReach passes when weapon reach >= engagement range`
  - `validateMeleeReach fails when weapon reach < engagement range`
  - `validateMeleeReach fails when at abstract far distance`
  - `checkOnPlayAttemptBlockers returns null when no blockers`
  - `checkOnPlayAttemptBlockers returns blocking card ID when rule matches`

### 2026-01-08: Module Structure Solution

**Problem**: Zig 0.15's module system requires files to belong to only one module. Integration tests at `src/testing/integration/` couldn't import domain code via relative paths (`../../domain/`) because they had a different module root.

**Solution**: Created `src/integration_tests.zig` as the integration test root, sitting at `src/` level so it can use relative imports to domain, data, and testing. Build.zig wires it up:

```zig
const integration_tests = b.addTest(.{
    .root_module = b.createModule(.{
        .root_source_file = b.path("src/integration_tests.zig"),
        ...
    }),
});
// Self-reference so harness can import via "integration_root"
integration_tests.root_module.addImport("integration_root", integration_tests.root_module);
```

Harness imports via: `const root = @import("integration_root");`

**Key files created/modified**:
- `src/integration_tests.zig` - new root that re-exports domain/data/testing
- `src/testing/integration/harness.zig` - the Harness struct
- `src/testing/integration/root.zig` - (unused, can delete)
- `src/data/mod.zig` - (unused, can delete)
- `build.zig` - integration test wiring

**Data fixes during integration**:
- Added `improvised` to `weapon.Category`
- Added defaults to `weapon.Grip`, `weapon.Features`, `weapon.Template`
- Fixed personas.zig weapon templates to match current schema

### Completed

- [x] Folder structure (`src/testing/integration/domain/`)
- [x] Harness struct with init/deinit
- [x] `addEnemyFromTemplate` - creates enemy using world's entity system
- [x] `giveCard`, `findAlwaysAvailable` - card helpers
- [x] `transitionTo`, `beginSelection` - phase control
- [x] Build targets working (`just test-integration`)
- [x] 3 harness tests passing
- [x] `playCard`, `commitPlays`, `resolveTick`, `resolveAllTicks` methods
- [x] Event assertion helpers (`expectEvent`, `expectNoEvent`, `hasEvent`, `drainEvents`, `clearEvents`)
- [x] 3 card_flow scenarios passing:
  - "Player plays thrust, stamina reserved, play created"
  - "Player plays thrust, resolves tick, stamina deducted"
  - "Pool card clone lifecycle: clone created"
- [x] Updated `testing_conventions` memory with harness API

### Outstanding

- [ ] Clean up unused files (`root.zig`, `data/mod.zig`) - files don't exist, already clean
- [ ] (Optional) Add more scenarios: modifier stacking, damage resolution, positioning

### 2026-01-08: Harness Play/Resolve Methods & Scenarios

Added remaining harness methods:
- `playCard(card_id, target)` - plays card via commandHandler
- `commitPlays()` - transitions to commit phase
- `resolveTick()` / `resolveAllTicks()` - resolves ticks (with proper cleanup)
- Event helpers: `hasEvent`, `expectEvent`, `expectNoEvent`, `drainEvents`, `clearEvents`
- `playerStamina()`, `playerAvailableStamina()` - stamina inspection
- `getPlays()` - returns timeline slots
- `hasActivePlays()` - checks if timeline has plays

Key implementation details:
- `beginSelection()` manually calls `initCombatState()` for player and enemies (bypasses event processor to give tests control over hand contents)
- `attachEventHandlers()` must be called after World.init to initialize commandHandler
- Events go to `next_events` buffer (not `current_events`) - harness reads from there
- TickResult from processTick needs deinit to avoid memory leaks

Wrote 3 card_flow scenarios demonstrating:
1. Play creation and stamina reservation
2. Tick resolution and stamina deduction
3. Pool card clone lifecycle

All tests pass: `just check` succeeds.